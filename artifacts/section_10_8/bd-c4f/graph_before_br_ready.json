[
  {
    "assignee": "PurpleHarbor",
    "created_at": "2026-02-20T07:36:40.869070676Z",
    "created_by": "ubuntu",
    "description": "Section: 10.8 — Operational Readiness\n\nStrategic Context:\nOperational readiness and fleet safety posture: control APIs, observability contracts, safe-mode operations, and disaster drills.\n\nExecution Requirements:\n- Preserve all scoped capabilities from the canonical plan.\n- Keep contracts self-contained so future contributors can execute without reopening the master plan.\n- Require explicit testing strategy (unit + integration/e2e) and structured logging/telemetry for every child bead.\n- Require artifact-backed validation for performance, security, and correctness claims.\n\nDependency Semantics:\n- This epic is blocked by its child implementation beads.\n- Cross-epic dependencies encode strategic sequencing and canonical ownership boundaries.\n\n## Success Criteria\n- All child beads for this section are completed with acceptance artifacts attached and no unresolved blockers.\n- Section-level verification gate for comprehensive unit tests, integration/e2e workflows, and detailed structured logging evidence is green.\n- Scope-to-plan traceability is explicit, with no feature loss versus the canonical plan section.\n\n## Optimization Notes\n- User-Outcome Lens: \"[PLAN 10.8] Operational Readiness\" must improve operator confidence, safety posture, and deterministic recovery behavior under both normal and adversarial conditions.\n- Cross-Section Coordination: child beads must encode integration assumptions explicitly to avoid local optimizations that degrade system-wide correctness.\n- Verification Non-Negotiable: completion requires reproducible unit/integration/E2E evidence and structured logs suitable for independent replay.\n- Scope Protection: any simplification must preserve canonical-plan feature intent and be justified with explicit tradeoff documentation.",
    "id": "bd-c4f",
    "issue_type": "epic",
    "notes": "Claimed by PurpleHarbor for section 10.8 epic closure verification/evidence pass.",
    "priority": 2,
    "status": "in_progress",
    "title": "[PLAN 10.8] Operational Readiness",
    "updated_at": "2026-02-22T03:03:49.867071178Z"
  },
  {
    "acceptance_criteria": "AC for bd-2ah:\n1. All critical flows adopt obligation-tracked two-phase channels from 10.15: Phase 1 (Prepare) reserves resources and returns an ObligationToken; Phase 2 (Commit/Rollback) consumes the token to finalize or release.\n2. An ObligationToken is a linear type (must be consumed exactly once); dropping an unconsumed token triggers a LEAKED_OBLIGATION panic in debug mode and a structured error log + forced rollback in release mode.\n3. The ObligationChannel<T> type enforces the two-phase contract: prepare(payload) -> Result<ObligationToken>, commit(token) -> Result<T>, rollback(token) -> Result<()>.\n4. Obligation tokens carry a monotonic sequence number and creation timestamp; tokens from a previous epoch (see bd-2gr) are automatically rejected with STALE_OBLIGATION_EPOCH.\n5. A configurable obligation timeout ensures that prepare-without-commit/rollback is detected: if a token is neither committed nor rolled back within the timeout, a background reaper logs OBLIGATION_TIMEOUT and forces rollback.\n6. The channel tracks outstanding obligation count as a gauge metric; the gauge must return to zero after all flows complete (verified in integration tests).\n7. Unit tests verify: (a) prepare -> commit round-trip succeeds, (b) prepare -> rollback releases resources, (c) dropped token triggers leak detection, (d) stale-epoch token is rejected, (e) timeout triggers forced rollback, (f) double-commit on same token returns OBLIGATION_ALREADY_CONSUMED.\n8. Structured log events: OBLIGATION_PREPARE / OBLIGATION_COMMIT / OBLIGATION_ROLLBACK / OBLIGATION_TIMEOUT / LEAKED_OBLIGATION with channel name, sequence number, and trace correlation ID.",
    "assignee": "CrimsonCrane",
    "created_at": "2026-02-20T07:36:50.060962999Z",
    "created_by": "ubuntu",
    "description": "Master Plan Source: PLAN_TO_CREATE_FRANKEN_NODE.md — Section 10.11 (FrankenSQLite-Inspired Runtime Systems), cross-ref Section 9G.3, 9J.19\n\n## Why This Exists\n\nCritical product flows in franken_node — publish-then-promote, rollback-then-notify, migration-commit-then-cleanup — require atomicity guarantees that simple fire-and-forget messaging cannot provide. If the publish succeeds but the promote notification is lost, the system enters an inconsistent state where a trust artifact is stored but not visible. Enhancement Map 9G.3 mandates obligation-tracked two-phase workflows for critical publish/rollback paths, where each message in a workflow carries a tracked obligation that must be explicitly fulfilled or compensated, and the system can audit at any time which obligations are outstanding. 9J.19 extends this with cancellation-complete protocol discipline, requiring that even cancelled workflows produce obligation closure proofs demonstrating that no obligations were silently dropped.\n\nThis bead adopts the canonical obligation-tracked two-phase channel contracts from 10.15 (bd-1n5p obligation channels) into franken_node's product service layer, replacing ad hoc messaging in critical flows with channels where every sent message creates a tracked obligation, the receiver must acknowledge or reject, and the system maintains an obligation ledger for auditability.\n\n## What This Must Do\n\n1. Implement an `ObligationChannel<T>` abstraction that wraps inter-service communication for critical flows, where every `send()` creates a tracked obligation with a unique obligation ID, deadline, and originating trace context.\n2. The receiver must explicitly `fulfill(obligation_id)` or `reject(obligation_id, reason)` — if neither occurs before the deadline, the channel emits an `ObligationTimeout` event and triggers the configured timeout policy (retry, compensate, or escalate).\n3. Maintain an `ObligationLedger` that tracks all outstanding obligations, their creation time, deadline, and current status — queryable for operational dashboards and audit.\n4. On cancellation of a workflow that has outstanding obligations, produce an obligation closure proof: a signed record listing each obligation and its terminal state (fulfilled, rejected, compensated, or cancelled-with-reason).\n5. Integrate with the append-only decision stream (per 9G.9): all obligation state transitions (created, fulfilled, rejected, timed-out, cancelled) are recorded as immutable events.\n6. Provide a `TwoPhaseFlow` builder that composes obligation channels into multi-step workflows with explicit prepare and commit phases, where prepare can be rolled back atomically.\n\n## Context from Enhancement Maps\n\n- 9G.3: \"Obligation-tracked two-phase workflows for critical publish/rollback paths\"\n- 9J.19: \"Cancellation-complete protocol discipline with obligation closure proofs\"\n- Architecture invariant #4 (8.5): Two-phase effects — critical state changes must go through prepare/commit.\n- Architecture invariant #3 (8.5): Cancellation protocol semantics — cancelled workflows must produce closure proofs.\n- Architecture invariant #8 (8.5): Evidence-by-default — obligation state transitions are evidence and must be recorded.\n\n## Dependencies\n\n- Upstream: bd-1n5p (10.15 obligation-tracked two-phase channels), bd-7om (cancel-drain-finalize protocol for cancellation integration), bd-126h (10.14 append-only marker stream for decision stream recording)\n- Downstream: bd-390 (anti-entropy reconciliation applies records through obligation channels), bd-3hw (saga orchestrator composes with obligation channels), bd-93k (checkpoint placement integrates with obligation tracking), bd-1jpo (10.11 section-wide verification gate)\n\n## Acceptance Criteria\n\n1. Every critical flow (publish-promote, rollback-notify, migration-commit-cleanup) uses `ObligationChannel` instead of direct messaging — verified by code audit gate.\n2. An unfulfilled obligation triggers `ObligationTimeout` event within 1 second of the deadline, with the configured policy (retry/compensate/escalate) executing automatically.\n3. The `ObligationLedger` correctly reports all outstanding obligations with creation time, deadline, and status — verified by querying during a multi-step workflow.\n4. Cancellation of a workflow with 3 outstanding obligations produces a closure proof listing all 3 obligations and their terminal states.\n5. Obligation closure proofs are signed and verifiable; a tampered proof fails verification.\n6. All obligation state transitions appear in the append-only decision stream in causal order.\n7. `TwoPhaseFlow` builder: a prepare phase that succeeds followed by a commit phase that fails triggers automatic rollback of the prepare, verified end-to-end.\n8. Verification evidence JSON includes obligations_created, obligations_fulfilled, obligations_timed_out, obligations_cancelled, closure_proofs_generated, and ledger_query_latency_ms fields.\n\n## Testing & Logging Requirements\n\n- Unit tests: (a) ObligationChannel send creates obligation with correct ID and deadline; (b) fulfill() transitions obligation to fulfilled state; (c) reject() transitions to rejected state; (d) Timeout fires at deadline; (e) Closure proof includes all obligations from a cancelled workflow.\n- Integration tests: (a) Full publish-promote flow through obligation channels with success path; (b) Publish-promote with promote failure triggering compensation; (c) Multi-step TwoPhaseFlow with rollback on commit failure; (d) Obligation ledger query during active workflow returns correct state.\n- Adversarial tests: (a) Double-fulfill of the same obligation — verify idempotent acceptance or rejection; (b) Fulfill after deadline — verify late fulfillment is recorded but does not suppress the timeout event; (c) Cancellation during the prepare phase of a TwoPhaseFlow — verify rollback and closure proof; (d) Obligation ledger under high concurrency (1000 concurrent obligations) — verify no lost obligations.\n- Structured logs: Events use stable codes (FN-OB-001 through FN-OB-012), include `obligation_id`, `trace_id`, `deadline`, `status`, `workflow_id`. JSON-formatted.\n\n## Expected Artifacts\n\n- docs/specs/section_10_11/bd-2ah_contract.md\n- crates/franken-node/src/runtime/obligation_channel.rs (or equivalent module path)\n- crates/franken-node/src/runtime/obligation_ledger.rs\n- crates/franken-node/src/runtime/two_phase_flow.rs\n- scripts/check_obligation_channels.py (with --json flag and self_test())\n- tests/test_check_obligation_channels.py\n- artifacts/section_10_11/bd-2ah/verification_evidence.json\n- artifacts/section_10_11/bd-2ah/verification_summary.md",
    "id": "bd-2ah",
    "issue_type": "task",
    "priority": 2,
    "status": "open",
    "title": "[10.11] Adopt canonical obligation-tracked two-phase channel contracts (from `10.15`) for critical flows.",
    "updated_at": "2026-02-22T02:59:22.274829053Z"
  },
  {
    "acceptance_criteria": "AC for bd-3he:\n1. A SupervisionTree structure models parent-child relationships between supervised actors/tasks, where each node has a configurable RestartBudget (max_restarts: u32, window: Duration).\n2. When a child fails, the supervisor applies the restart policy: if restarts remaining in the current window > 0, restart the child and decrement the budget; if budget is exhausted, escalate to the parent supervisor.\n3. Escalation policies are configurable per node: RestartChild (default), RestartAllChildren (one-for-all), EscalateToParent, and ShutdownSubtree.\n4. The root supervisor has no parent; budget exhaustion at the root triggers a controlled system shutdown with SUPERVISION_ROOT_EXHAUSTED event and a full tree status dump.\n5. Restart budgets use a sliding window (not fixed intervals): the window tracks the timestamp of each restart and expires old entries, so bursts are correctly detected.\n6. Each supervisor node exposes metrics: restart_count (counter), active_children (gauge), budget_remaining (gauge), and escalation_count (counter).\n7. The supervision tree integrates with the cancellation protocol (bd-7om): shutting down a subtree sends cancel -> drain -> finalize to all children in reverse dependency order (leaves first, then parents).\n8. Unit tests verify: (a) child restart within budget succeeds, (b) budget exhaustion triggers escalation, (c) one-for-all policy restarts all siblings, (d) root exhaustion triggers shutdown, (e) sliding window correctly expires old restarts, (f) subtree shutdown follows cancel -> drain -> finalize order.\n9. Structured log events: CHILD_STARTED / CHILD_FAILED / CHILD_RESTARTED / BUDGET_EXHAUSTED / ESCALATION_TRIGGERED / SUBTREE_SHUTDOWN with supervisor path and child ID.",
    "created_at": "2026-02-20T07:36:50.140473702Z",
    "created_by": "ubuntu",
    "description": "[10.11] Implement supervision tree with restart budgets and escalation policies.\n\n## Why This Exists\n\nReliable systems require deterministic failure containment. When a component fails, the system must decide: restart it, escalate to a parent supervisor, or shut down gracefully. Without a structured supervision tree, failure handling is ad-hoc — some components retry infinitely, others crash the entire process, and failure cascades are unpredictable. This bead implements an Erlang-inspired supervision tree for franken_node's product services, providing configurable restart budgets, escalation policies, and bounded recovery behavior. This is foundational for the reliability guarantees referenced throughout sections 10.11 and 10.12.\n\n## What It Must Do\n\n1. **Supervisor abstraction.** Implement a `Supervisor` struct that manages a set of child workers or nested supervisors. Each supervisor has a `SupervisionStrategy`: `OneForOne` (restart only the failed child), `OneForAll` (restart all children if any fails), or `RestForOne` (restart the failed child and all children started after it).\n\n2. **Restart budgets.** Each supervisor has a restart budget: `max_restarts` within a `time_window` (e.g., 5 restarts in 60 seconds). When the budget is exhausted, the supervisor does not restart the child — instead it escalates to its own parent supervisor. Budget tracking uses a sliding window, not a fixed window.\n\n3. **Escalation policies.** When a supervisor exhausts its budget, it reports the failure to its parent. The parent can: absorb the failure (reset child supervisor's budget), propagate the escalation upward, or trigger a graceful shutdown of the entire subtree. Escalation chains are bounded — a maximum escalation depth is configurable (default: 5 levels).\n\n4. **Child specifications.** Each child is defined by a `ChildSpec` that includes: name, start function, restart type (`Permanent` — always restart, `Transient` — restart only on abnormal exit, `Temporary` — never restart), shutdown timeout, and capability profile reference (from bd-cvt).\n\n5. **Graceful shutdown sequencing.** When a supervisor shuts down, it stops children in reverse start order, respecting each child's shutdown timeout. If a child doesn't stop within its timeout, it is forcefully terminated. Shutdown progress is logged.\n\n6. **Health reporting integration.** Each supervisor exposes health status: number of active children, restart count within current window, budget remaining, and escalation state. This feeds into the health gate system (health_gate.rs).\n\n7. **Deterministic testing.** The supervision tree must be testable with deterministic simulated failures. A test harness allows injecting failures at specific children and asserting the resulting restart/escalation sequence.\n\n## Acceptance Criteria\n\n1. `Supervisor`, `ChildSpec`, and `SupervisionStrategy` types implemented in `crates/franken-node/src/connector/supervision.rs`.\n2. All three strategies (`OneForOne`, `OneForAll`, `RestForOne`) are implemented with tests.\n3. Restart budget with sliding window correctly limits restarts and triggers escalation.\n4. Escalation chain terminates at configurable max depth with graceful shutdown.\n5. Graceful shutdown respects reverse-order and per-child timeouts.\n6. Health reporting exposes active children, restart count, and budget remaining.\n7. Deterministic test harness exercises at least 10 failure scenarios.\n8. Verification script `scripts/check_supervision_tree.py` with `--json` flag confirms all criteria.\n9. Evidence artifacts written to `artifacts/section_10_11/bd-3he/`.\n\n## Key Dependencies\n\n- bd-cvt (capability profiles) — child specs reference capability profiles.\n- health_gate.rs — health reporting integration.\n- Tokio runtime for async supervision (if async workers are used).\n- 10.13 stable error namespace for supervision error codes.\n\n## Testing & Logging Requirements\n\n- Unit tests covering each supervision strategy, budget exhaustion, escalation, and shutdown sequencing.\n- Integration test with a 3-level supervision tree where leaf workers are injected with failures.\n- Property-based tests confirming that restart count never exceeds budget within any sliding window.\n- Structured logging: `supervisor.child_started`, `supervisor.child_failed`, `supervisor.child_restarted`, `supervisor.budget_exhausted`, `supervisor.escalation`, `supervisor.shutdown_started`, `supervisor.shutdown_complete` events.\n\n## Expected Artifacts\n\n- `docs/specs/section_10_11/bd-3he_contract.md` — specification document.\n- `crates/franken-node/src/connector/supervision.rs` — Rust implementation.\n- `scripts/check_supervision_tree.py` — verification script.\n- `tests/test_check_supervision_tree.py` — unit tests.\n- `artifacts/section_10_11/bd-3he/verification_evidence.json` — evidence.\n- `artifacts/section_10_11/bd-3he/verification_summary.md` — summary.",
    "id": "bd-3he",
    "issue_type": "task",
    "notes": "Plan-space QA addendum (2026-02-20):\n1) Preserve full canonical-plan scope; no feature compression or silent omission is allowed.\n2) Completion requires comprehensive verification coverage appropriate to scope: unit tests, integration tests, and E2E scripts/workflows with detailed structured logging (stable event/error codes + trace correlation IDs).\n3) Completion requires reproducible evidence artifacts (machine-readable + human-readable) that allow independent replay and root-cause triage.\n4) Any implementation PR for this bead must include explicit links to the above test/logging artifacts.",
    "priority": 2,
    "status": "open",
    "title": "[10.11] Implement supervision tree with restart budgets and escalation policies.",
    "updated_at": "2026-02-20T17:14:28.354322233Z"
  }
]
